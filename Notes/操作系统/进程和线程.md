#### 进程和线程的区别

进程：分配资源的基本单位，处于执行期的程序以及相关资源的总称
线程：cpu调度的基本单位，进程中的活动对象
不同的进程有不同的进程id，不同的线程有相同的进程id，不同的线程id
同一进程的不同线程共享地址空间，打开的文件描述符，信号处理函数，当前目录、用户id
进程创建和切换开销更大
不同线程有不同的栈和寄存器

#### 进程的状态

![](https://cdn.nlark.com/yuque/0/2021/png/23154882/1636179877376-443b40f9-0d45-4e4f-813f-4d7060ca0aea.png)

**linux中进程的状态**

- 运行状态：可执行。正在运行或者等待执行
- 可中断：进程正在阻塞
- 不可中断：忙等，关中断
- TRACED:被跟踪
- 停止：没有运行且不能投入运行

进程创建fork，vfork和clone
最终都会调用do_fork系统调用
fork时使用写时拷贝，子进程共享父进程地址空间，代价仅仅是创建子进程的页表结构和创建一个task_struct结构
标准输出重定向fork之后打印两次
将标准输出重定向到一个文件时，f这个时候标准I/O就变成了一个全缓冲区（当缓冲区或者程序结束才会将缓冲区的数据输出），所以在第一次printf的时候，因为缓冲区没有满所以不会将数据打印出来，而是存在缓冲区中。fork函数将父进程复制完后，会将这个缓冲区也复制下来，所以在子程序的第二个printf中，会在已有的缓冲区数据后面再增加数据，最后在子程序的第二个printf中就会将两个数据一起输出出来。

#### fork与vfork区别

执行次序：

vfork是先调用子进程，等子进程的_exit（exit是不正确的）或exec被调用后，再调用父进程。
fork对父子进程的调度室由调度器决定的。
数据段的影响：
fork采用的是写时复制技术。
vfork的父子进程是共享数据的，所以在子程序中修改变量，父进程的变量也会被修改。（在fork中不会这样）
vfork之后需要调用exec 或者exit，直接调用return会导致未定义行为
线程创建由clone实现
线程clone参数：共享地址空间，共享文件系统，共享打开的文件，共享信号处理程序
