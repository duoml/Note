## 使用锁的缺点

1. 阻塞等待，无法实时响应
2. DeadLock
3. LiveLock
4. 优先级反转
5. 使用不当导致性能问题

## 优先级反转

线程1加锁A,优先级10，线程2，优先级20，加锁A失败，阻塞。此时若有线程3，优先级15，抢占线程1，导致线程2必须等到线程3执行完，就是优先级翻转

**如何避免（优先级继承）**

高优先级task获取锁时，提高以获得锁的task优先级。

**mutex**

1. 可以优先级继承
2. 不能在中断中使用
3. 获得和释放必须在同一个task

**信号量**

1. 没有优先级继承
2. 可以在中断中使用

## 条件变量

使用时注意两个约束

- 保证 ready == false 判断成立和 调用 wait 进入唤醒队列的原子性
- 设置 ready = true 在 signal 唤醒之前

### signal与unlock顺序

最好先signal，再unlock。
先unlock再signal可能会有其他线程先获取了锁，导致优先级反转
pthread实现可以直接从条件变量队列转移等待线程到互斥队列，而不唤醒它，以避免"hurry up and wait"场景。
